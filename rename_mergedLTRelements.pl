#!/usr/bin/perl -w
#######################################################
# Author :  Jainy Thomas
# date   :  May 2017
# email  :  jainythomas1@gmail.com
# Pupose :  Rename the LTR output file generated by one code to find them all based on the fragments created
#			
#####################################################
use warnings;
use strict;
use Carp;
use Getopt::Long;
use Data::Dumper;

my $version = "4.0";
my $scriptname = "rename_mergedLTRelements.pl";
my $changelog = "
#   - v1.0 = 22 May 2017 
#
#	- v2.0 = 25 May 2017 
#		include the length aspect of the LTR elements
#	- v3.0 = 9 October 2017
#		modified to script to enable the use for any LTR-Internal sequence combination of one code find them all output
#	- v4.0 = 12 October 2017
#		modified script to use multiple LTR sequences for an internal sequence
#	- v5.0 = prints in the bedoutput format
#
\n";
my $usage = "\nUsage [$version]: 
    perl $scriptname -f <file that needs to renamed> -ltr <name of ltr=length of LTR> -int <name of internalsequence> -ilen<length of internalsequence> -rn <name that you would like give>[-v] [-c] [-h] 
	
	MANDATORY ARGUMENT:	
 
    -f,   	--file          	(STRING) file
    -ltr,  	--ltrname       	(STRING) Name of the ltr that needs to be rejoined=length of the ltr that can be classified as soloLTR (~5-10 bp length less than consensus length) 
								e.g. -ltr MER66C=550 -ltr MER66B=481 -ltr MER66D=479
	-int,  	--internalname  	(STRING) Name of the internal erv sequence that needs to be rejoined
								
	-ilen, 	--length of the
				internal region (STRING) length of the total internal sequence that can be classified as complete (~5-10 bp length less than consensus length)
    -rn,   	--rename			(STRING) the name that you would like to give to the element (eg. HERVH or HERVW or HERV17)
   
    OPTIONAL ARGUMENTS:
    -o,--out	(STRING) name of the output file
    -c,--chlog  (BOOL)   Print updates
    -v,--v      (BOOL)   Print version if only option
    -s,--verbose(BOOL)   The script will talk to you
    -h,--help>  (BOOL)   Print this usage\n\n";
   
#-----------------------------------------------------------------------------
#------------------------------ LOAD AND CHECK -------------------------------
#-----------------------------------------------------------------------------
my ($file,$out,%ltrname,$intname,$intlen,$rename,$help,$v,$chlog);
GetOptions ('f=s'   => \$file,
            'o=s'   => \$out,
            'ltr=s' => \%ltrname,#takes multiple key=values
            'int=s' => \$intname,
            'ilen=s'=> \$intlen,
            'rn=s'  => \$rename,	
            'c'     => \$chlog, 
            'h'     => \$help,
            'v'     => \$v);

#check step to see if mandatory argument is provided + if help/changelog
die "\n Script $scriptname version $version\n\n" if ((! $file)&&  (! $help) && (! $chlog) && ($v));
die $changelog if ($chlog);
die $usage if ((! $file) || (! $intname)||(! $intlen)||(! $rename)||($help));

$out = "$file.newnames.cordinates.txt" if (! $out);

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
my @elements = ();
my %genomelocation;
my $genomeloc;

&load_hash();
&rename_elements();
#print Dumper %genomelocation;

exit;
#-------------------------------------------------------------------------------
#----------------------------------- SUB ---------------------------------------
#-------------------------------------------------------------------------------

sub load_hash {
	open (my $fh,"<",$file) || die ("cannot open file $file to read $!\n");
		while (<$fh>) {
		chomp (my $line = $_);
	
		my @col = split (/\t/,$line);
			if ($line =~ /^###/) {
				@elements = ();
				$genomeloc = "$col[4]\t$col[5]\t$col[6]\t$col[7]\t$col[8]";
				push (@elements,{$col[9] => $col[7]});
				$genomelocation{$genomeloc} = [@elements];
			} else {
				push (@{$genomelocation{$genomeloc}},{$col[9] => $col[7]});#add key value pair to the array
			} 
		}

}	

sub rename_elements {
	open (my $fhout,">",$out) || die ("cannot open file $out to write $!\n");
	my $num = 0;
	foreach my $element (sort keys %genomelocation) {
		$num++;
		my $ltr = 0 ;
		my $Hervhint = 0;
		my $ltrlength;
		my $intlength;
		my $ltrlen;
		#print "$element\t @{$genomelocation{$element}}\n";
		my $numelements = @{$genomelocation{$element}};
		shift (@{$genomelocation{$element}}) if ($numelements > 2) ;#duplication of type because including ### line as well
		foreach my $hash_ref (@{$genomelocation{$element}}) {
			foreach my $type (keys %{$hash_ref}) {
				
				#$ltrlength = ${$hash_ref}{$type} if ($type eq "$ltrname");
				$ltrlength = ${$hash_ref}{$type} if (exists ($ltrname{$type}));
				#print "$type => ${$hash_ref}{$type}\n";
				$ltrlen = $ltrname{$type}; 
				#print "$ltrlen required length";
				$intlength = ${$hash_ref}{$type} if ($type eq "$intname");
				
				$ltr++ if (exists ($ltrname{$type}));
				$Hervhint++ if ($type eq "$intname");
			}
		}
		my @loc = split (/\t/, $element);
		my $new_id = join("\t",$loc[0],$loc[1],$loc[2]);
		if (($ltr == 2) && ($Hervhint > 1)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_2ltr_int_fr_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr == 2) && ($Hervhint == 1)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_2ltr_int_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr == 1) && ($Hervhint == 1)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_1ltr_int_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr == 1) && ($Hervhint > 1)) {	
			print $fhout "$new_id\t$rename"."_$loc[0]_1ltr_int_fr_$num\t$loc[3]\t$loc[4]\n";
		} elsif (($ltr == 0) && ($Hervhint == 1) && ($intlength >= $intlen)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_int_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr == 0) && ($Hervhint == 1) && ($intlength < $intlen)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_int_fr_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr == 0) && ($Hervhint > 1)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_int_fr_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr == 1) && ($Hervhint == 0) && ($ltrlength >= $ltrlen)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_Sltr_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr == 1) && ($Hervhint == 0) && ($ltrlength < $ltrlen)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_Sltr_fr_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr > 1) && ($Hervhint == 0)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_Sltr_fr_$num\t$loc[3]\t$loc[4]\n" ;
		} elsif (($ltr > 2) && ($Hervhint > 1)) {
			print $fhout "$new_id\t$rename"."_$loc[0]_2ltr_int_fr_$num\t$loc[3]\t$loc[4]\n" ;
		} else {
			print $fhout "$new_id\t$rename.notdefined\n";
		}
		
	}
	close ($fhout);
}

